// Generated by CoffeeScript 2.0.0-beta4
// Modal

// 彈出式視窗。
var Modal;

Modal = (function() {
  class Modal {
    constructor() {
      // 元素初始化函式。
      this.init = this.init.bind(this);
      // 元素摧毀函式。
      this.destroy = this.destroy.bind(this);
      // Get Dimmer

      // 初始化一個淡化幕如果有必要的話，最終回傳一個全域對話視窗淡化幕。
      this.getDimmer = this.getDimmer.bind(this);
      // Open

      // 開啟一個對話視窗。
      this.open = this.open.bind(this);
      // Close

      // 關閉一個對話視窗。
      this.close = this.close.bind(this);
      // 模組可用的方法。
      this.methods = this.methods.bind(this);
    }

    init() {
      var $dimmer;
      // 取得全域對話視窗淡化幕。
      $dimmer = this.getDimmer();
      // 如果這個對話視窗不在淡化幕內，我們就將這個對話視窗移入淡化幕裡。
      if (!this.$this.parent().hasClass(this.className.MODALS_DIMMER)) {
        this.$this.appendTo($dimmer);
      }
      // 依據這個對話視窗是否可供關閉，來決定是否要追加指定樣式類別。
      if (this.$this.data('closable')) {
        this.$this.addClass(this.className.CLOSABLE);
      } else {
        this.$this.removeClass(this.className.CLOSABLE);
      }
      // 如果這個對話視窗是可供關閉而且又允許透過鍵盤快捷鍵關閉，
      // 那麼就綁定「Esc」按鍵事件到頁面上並指定關閉這個對話視窗。
      if (this.$this.data('keyboardShortcuts') && this.$this.data('closable')) {
        $selector(document).on('keyup.modal', (event) => {
          var ref;
          // 如果不是 Esc 按鍵則返回。
          if (event.keyCode !== 27) {
            return;
          }
          // 如果沒有正在顯示且可供忽略的對話視窗，那麼就返回。
          if ($selector(this.selector.CLOSABLE_ACTIVE_MODAL).length === 0) {
            return;
          }
          // 如果淡化幕已經正在關閉了，就返回。避免雙重觸發關閉事件。
          if ($selector(this.selector.CLOSING_MODALS_DIMMER).length !== 0) {
            return;
          }
          // 關閉視窗。
          this.close();
          return (ref = this.$this.data('onIgnore')) != null ? ref.call(this.$this.get()) : void 0;
        });
      }
      // 綁定「允許」按鈕的事件。
      this.$this.find(this.$this.data('approve')).on('click', () => {
        var ref;
        if (((ref = this.$this.data('onApprove')) != null ? ref.call(this.$this.get()) : void 0) !== false) {
          return this.close();
        }
      });
      // 綁定「拒絕」按鈕的事件。
      this.$this.find(this.$this.data('deny')).on('click', () => {
        var ref;
        if (((ref = this.$this.data('onDeny')) != null ? ref.call(this.$this.get()) : void 0) !== false) {
          return this.close();
        }
      });
      // 綁定「關閉」按鈕的事件。
      this.$this.find(this.selector.CLOSE_BUTTON).on('click', () => {
        return this.close();
      });
      return ts.fn;
    }

    destroy() {}

    getDimmer() {
      var $dimmer;
      // 取得全域對話視窗淡化幕。
      $dimmer = $selector(this.selector.MODALS_DIMMER);
      // 如果有的話就直接回傳淡化幕元素。
      if ($dimmer.length !== 0) {
        return $dimmer;
      }
      // 沒有的話就建立一個新的對話視窗淡化幕。
      $dimmer = $selector(this.selector.DIV).addClass(this.className.MODALS_DIMMER);
      // 將淡化幕推入到網頁中。
      $selector(this.selector.BODY).append($dimmer);
      // 綁定淡化幕被按下時，自動關閉對話視窗的點擊事件。
      $dimmer.on('click', (event) => {
        var $activeModal, ref;
        // 如果點擊淡化幕但目標其實是子元素就離開。
        if (event.target !== $dimmer.get()) {
          return;
        }
        // 找尋可供點擊關閉的對話視窗。
        $activeModal = $dimmer.find(this.selector.CLOSABLE_ACTIVE_MODAL);
        // 如果沒有的話就離開。
        if ($activeModal.length === 0) {
          return;
        }
        // 關閉可供點擊關閉的對話視窗。
        this.$this = $activeModal;
        this.close();
        return (ref = this.$this.data('onIgnore')) != null ? ref.call(this.$this.get()) : void 0;
      });
      // 回傳這個新的淡化幕。
      return $dimmer;
    }

    async open() {
      // 如果要開啟的對話視窗早已開啟，就離開此程式。
      //if @$this.hasClass(@className.ACTIVE)
      //    return

      // 如果有已開啟的對話視窗則關閉它。
      if ($selector(this.selector.ACTIVE_MODAL).length !== 0) {
        ts(this.selector.ACTIVE_MODAL).modal('hide');
        await this.delay(this.duration);
      }
      // 鎖定頁面的捲動。
      $selector(this.selector.BODY).attr('data-modal-lock', 'true');
      // 將對話視窗的淡化幕設置為啟用、開啟中。
      this.$this.parent().addClass(`${this.className.ACTIVE} ${this.className.OPENING}`);
      // 將對話視窗設置為啟用、開啟中。
      // 當對話視窗的動畫執行結束後，就移除自己還有淡化幕的開啟中樣式。
      return this.$this.addClass(`${this.className.ACTIVE} ${this.className.OPENING}`).one('animationend', () => {
        this.$this.removeClass(this.className.OPENING);
        return this.$this.parent().removeClass(this.className.OPENING);
      });
    }

    close() {
      // 如果這個對話視窗本來就沒有啟用，就不需要執行接下來的關閉程式。
      if (!this.$this.hasClass(this.className.ACTIVE)) {
        return;
      }
      // 解除頁面的捲動鎖定。
      $selector(this.selector.BODY).removeAttr('data-modal-lock');
      // 將對話視窗的淡化幕設置為關閉中。
      this.$this.parent().addClass(this.className.CLOSING);
      // 將對話視窗設置為啟用、關閉中。
      // 當對話視窗的動畫執行結束後，就移除自己還有淡化幕的關閉中樣式。
      return this.$this.addClass(`${this.className.ACTIVE} ${this.className.CLOSING}`).one('animationend', () => {
        this.$this.removeClass(`${this.className.ACTIVE} ${this.className.CLOSING}`);
        this.$this.parent().removeClass(`${this.className.ACTIVE} ${this.className.CLOSING}`);
        // 呼叫關閉時的事件函式。
        return this.$this.data('onClose').call(this.$this.get());
      });
    }

    methods() {
      return {
        // Show

        // 顯示對話視窗。
        show: () => {
          this.open();
          return ts.fn;
        },
        // Hide

        // 隱藏對話視窗。
        hide: () => {
          this.close();
          return ts.fn;
        },
        // Toggle

        // 切換對話視窗。
        toggle: () => {
          if (this.$this.hasClass(this.className.ACTIVE)) {
            this.close();
          } else {
            this.open();
          }
          return ts.fn;
        },
        // Is Active

        // 回傳一個表示對話視窗是否正在顯示的布林值。
        'is active': () => {
          return this.$this.hasClass(this.className.ACTIVE);
        }
      };
    }

  };

  // 模組名稱。
  Modal.module = 'modal';

  // 模組屬性。
  Modal.prototype.props = {
    // 會呼叫同意回呼函式的元素選擇器。
    approve: '.approve, .positive, .ok',
    // 會呼叫拒絕回呼函式的元素選擇器。
    deny: '.deny, .negative, .cancel',
    // 是否可由點擊背景來關閉對話視窗。
    closable: true,
    // 同意時所被呼叫的函式，如果這個函式回傳 false 的話將不會關閉對話視窗。
    onApprove: () => {
      return true;
    },
    // 拒絕時所被呼叫的函式，如果這個函式回傳 false 的話將不會關閉對話視窗。
    onDeny: () => {
      return true;
    },
    // 當視窗被關閉時所呼叫的函式。
    onClose: () => {},
    // 當視窗是以點擊背景關閉時所呼叫的函式。
    onIgnore: () => {},
    
    onShow: () => {},
    
    onVisible: () => {},
    
    onClosed: () => {},
    
    duration: 250,
    // 是否綁定鍵盤快捷鍵，如 Esc 鍵以關閉視窗。
    keyboardShortcuts: true
  };

  // 對話視窗的動畫效果。
  Modal.prototype.duration = 250;

  // 臨時對話視窗的標籤名稱。
  Modal.prototype.temporaryName = 'data-modal-temporary';

  // 類別樣式名稱。
  Modal.prototype.className = {
    MODAL: 'ts modal',
    MINI_MODAL: 'ts mini modal',
    MODALS_DIMMER: 'ts modals dimmer',
    SIZES: 'mini tiny small large',
    CLOSABLE: 'closable',
    ACTIVE: 'active',
    OPENING: 'opening',
    CLOSING: 'closing'
  };

  // 選擇器名稱。
  Modal.prototype.selector = {
    CLOSE_BUTTON: ':scope > .ts.close.button',
    MODALS_DIMMER: '.ts.modals.dimmer',
    CLOSING_MODALS_DIMMER: '.ts.modals.closing.dimmer',
    CLOSABLE_ACTIVE_MODAL: '.ts.modal.active.closable',
    ACTIVE_MODAL: '.ts.active.modal',
    BODY: 'body',
    DIV: '<div>',
    TEMP_MODAL: `[${Modal.prototype.temporaryName}]`,
    TEMP_MODAL_INPUT: `[${Modal.prototype.temporaryName}] .ts.input > *`
  };

  return Modal;

})();

ts(Modal);


// Prompt

// 讓使用者能夠產生臨時輸入對話視窗的函式，
// 基本上就是更短的 `ts.modal()`。
ts.prompt = (title, value = '', onApprove = function() {
    return true;
  }) => {
  return ts.modal({
    title: title,
    prompt: {
      type: 'input',
      value: value
    },
    closable: false,
    onApprove: onApprove
  });
};

// Modal

// 讓使用者能夠產生臨時對話視窗的函式。
ts.modal = async(title, content, onClose = function() {}) => {
  var $modal, cancel, delay, hasModal, isTextarea, negative, ok, options, placeholder, positive, prompt, ref, value;
  // 取得現有的臨時對話視窗。
  $modal = $selector(Modal.prototype.selector.TEMP_MODAL);
  // 是否有臨時對話視窗的布林值。
  hasModal = $modal.length !== 0;
  // 延遲函式。
  delay = function(time = 0) {
    return new Promise(function(resolve) {
      return setTimeout(resolve, time);
    });
  };
  // 如果有臨時對話視窗。
  if (hasModal) {
    // 而且該對話視窗是啟用狀態的話。
    if ($modal.hasClass(Modal.prototype.className.ACTIVE)) {
      // 隱藏原先的對話視窗。
      ts(Modal.prototype.selector.TEMP_MODAL).modal('hide');
      // 延遲一小段時間讓對話視窗隱藏後才繼續接下來的動作。
      // 避免視窗還沒隱藏，就改變其外觀看起來會很詭異。
      await delay(Modal.prototype.duration);
      // 重設對話視窗的尺寸樣式。
      $modal.removeClass(Modal.prototype.className.SIZES);
    }
  } else {
    // 如果沒有臨時對話視窗，就自己建立一個，然後推入 Body 中。
    $modal = $selector('<div>').attr(Modal.prototype.temporaryName, 'true').appendTo($selector('body'));
  }
  // 如果 `title` 不是物件，就表示這是簡易對話視窗。
  if (typeof title !== 'object') {
    // 將簡易對話視窗設置為迷你型的，並加上 Tocas 前輟。
    // 然後套用 HTML 原始碼。
    $modal.addClass(Modal.prototype.className.MINI_MODAL).html(`<div class=\"header\">${title}</div>\n<div class=\"content\">${content}</div>\n<div class=\"actions\">\n    <button class=\"ts ok button\">\n        確定\n    </button>\n</div>`);
    // 選擇臨時簡易對話視窗，然後初始化它，並在關閉時呼叫關閉函式。
    // 初始化完之後就顯示臨時對話視窗。
    ts(Modal.prototype.selector.TEMP_MODAL).modal({
      onClose: async() => {
        // 呼叫關閉函式，並回傳臨時對話視窗元素。
        onClose.call($modal.get());
        // 等待對話視窗關閉動畫。
        await delay(Modal.prototype.duration);
        if (!$selector(Modal.prototype.selector.TEMP_MODAL).hasClass('active')) {
          // 如果此時的臨時對話視窗沒有任何啟用樣式，
          // 也就代表沒有另一個行為在開啟對話視窗，我們就可以安心移除這個臨時對話視窗了。
          return $modal.remove();
        }
      }
    }).modal('show');
    return;
  }
  // 定義進階臨時對話視窗的可用選項。
  options = {
    // 對話視窗的標題，可支援 HTML 原始碼。
    title: null,
    // 對話視窗的內容，可支援 HTML 原始碼。
    content: null,
    // 是否可供 Esc 或點擊淡化幕來關閉對話視窗。
    closable: true,
    // 如果這是一個物件而且 `type` 不是 `nbull` 的話，
    // 對話視窗就會轉換為可供輸入的 Prompt 型態的視窗。
    prompt: {
      // 輸入欄位的種類，可以是 `input` 或 `textarea`。
      type: null,
      // 輸入欄位的預置文字。
      placeholder: null,
      // 輸入欄位的預設值。
      value: null
    },
    // 對話視窗的大小。
    size: 'mini',
    // 對話視窗的動作按鈕文字，當按鈕是 `null` 值時不會顯示。
    actions: {
      // 正面的按鈕文字。
      positive: null,
      // 負面的按鈕文字。
      negative: null,
      // 無語氣的確定按鈕文字。
      ok: '確定',
      // 無語氣的取消按鈕文字。
      cancel: null
    },
    // 當正面或確定按鈕被按下時所會呼叫的回呼函式，回傳 `false` 會令對話視窗無法關閉。
    onApprove: function() {
      return true;
    },
    // 當負面或取消按鈕被按下時所會呼叫的回呼函式，回傳 `false` 會令對話視窗無法關閉。
    onDeny: function() {
      return true;
    },
    // 當對話視窗關閉時所會呼叫的回呼函式。
    onClose: function() {},
    // 當對話視窗因為點擊淡化幕或者按下 Esc 關閉時所會呼叫的函式。
    onIgnore: function() {}
  };
  // 將預設選項與使用者傳入的選項混雜在一起並覆蓋。
  options = Object.assign({}, options, title);
  // 如果有標題的話就以模板初始化。
  title = options.title != null ? `<div class='header'>${options.title}</div>` : '';
  content = options.content != null ? options.content : '';
  cancel = options.actions.cancel != null ? `<button class='ts cancel button'>${options.actions.cancel}</button>` : '';
  ok = options.actions.ok != null ? `<button class='ts ok button'>${options.actions.ok}</button>` : '';
  negative = options.actions.negative != null ? `<button class='ts negative button'>${options.actions.negative}</button>` : '';
  positive = options.actions.positive != null ? `<button class='ts positive button'>${options.actions.positive}</button>` : '';
  prompt = '';
  // 如果這個對話視窗有指定輸入的型態，就建立一個輸入欄位供稍後插入。
  if (((ref = options.prompt) != null ? ref.type : void 0) != null) {
    // 是否有指定輸入欄位要是 `textarea` 型態的布林值。
    isTextarea = options.prompt.type === 'textarea';
    // 取得預置文字。
    placeholder = options.prompt.placeholder != null ? options.prompt.placeholder : '';
    // 取得預設值。
    value = options.prompt.value != null ? options.prompt.value : '';
    // 依照要求的輸入欄位型態產生。
    prompt = isTextarea ? `<div class=\"ts fluid input\">\n    <textarea style=\"resize: vertical\" rows=\"3\" placeholder=\"${placeholder}\">${value}</textarea>\n</div>` : `<div class=\"ts fluid input\">\n    <input type=\"text\" placeholder=\"${placeholder}\" value=\"${value}\">\n</div>`;
    // 如果有內容，又有輸入欄位的話，就在輸入欄位前面多一些換行。
    if (content !== '' && prompt !== '') {
      prompt = `<br><br>${prompt}`;
    }
  }
  // 加上尺寸選項，並且套用相關 HTML 原始碼，還有 Tocas 前輟來初始化這個臨時對話視窗。
  $modal.addClass(`${Modal.prototype.className.MODAL} ${options.size}`).html(`${title}\n<div class=\"content\">\n    ${content}\n    ${prompt}\n</div>\n<div class=\"actions\">\n    ${cancel}\n    ${ok}\n    ${negative}\n    ${positive}\n</div>`);
  // 如果輸入欄位是一般的 `input`，而且這又是個輸入視窗的話。
  if (!isTextarea && prompt !== '') {
    // 監聽輸入欄位的按鍵事件。
    $selector(Modal.prototype.selector.TEMP_MODAL_INPUT).on('keydown', (event) => {
      // 如果按下的按鍵不是 Enter 就離開。
      if (event.keyCode !== 13) {
        return;
      }
      // 否則就呼叫對話視窗的隱藏函式。
      ts(Modal.prototype.selector.TEMP_MODAL).modal('hide');
      // 並且呼叫確定的回呼函式且帶入輸入欄位的數值。
      // 模擬使用者按下 Enter 送出資料的手法。
      return options.onApprove.call($modal.get(), $selector(Modal.prototype.selector.TEMP_MODAL_INPUT).val());
    });
  }
  // 然後初始化這個進階的臨時對話視窗，接著顯示它。
  return ts(Modal.prototype.selector.TEMP_MODAL).modal({
    closable: options.closable,
    onApprove: function() {
      return options.onApprove.call($modal.get(), $selector(Modal.prototype.selector.TEMP_MODAL_INPUT).val());
    },
    onDeny: function() {
      return options.onDeny.call($modal.get(), $selector(Modal.prototype.selector.TEMP_MODAL_INPUT).val());
    },
    onClose: async function() {
      options.onClose.call($modal.get(), $selector(Modal.prototype.selector.TEMP_MODAL_INPUT).val());
      // 等待對話視窗關閉動畫。
      await delay(Modal.prototype.duration);
      if (!$modal.hasClass(Modal.prototype.className.ACTIVE)) {
        // 如果此時的臨時對話視窗沒有任何啟用樣式，
        // 也就代表沒有另一個行為在開啟對話視窗，我們就可以安心移除這個臨時對話視窗了。
        return $modal.remove();
      }
    },
    onIgnore: function() {
      return options.onIgnore.call($modal.get(), $selector(Modal.prototype.selector.TEMP_MODAL_INPUT).val());
    }
  }).modal('show');
};
