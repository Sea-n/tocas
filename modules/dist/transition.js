// Generated by CoffeeScript 2.0.0-beta4
// Transition

// 過場效果。
var Transition;

Transition = (function() {
  class Transition {
    constructor() {
      // 類別樣式名稱。
      //className:

      // 選擇器名稱。
      //selector:

      // 元素初始化函式。
      this.init = this.init.bind(this);
      // 元素摧毀函式。
      this.destroy = this.destroy.bind(this);
      
      this.untilVisible = this.untilVisible.bind(this);
      
      this.push = this.push.bind(this);
      
      this.start = this.start.bind(this);
      
      this.animate = this.animate.bind(this);
      
      this.getAnimation = this.getAnimation.bind(this);
      // 模組可用的方法。
      this.methods = this.methods.bind(this);
    }

    init({animation, duration, onComplete, interval}) {
      
      //if animation is null
      //    ts.fn

      this.push(animation, duration, onComplete, interval);
      return ts.fn;
    }

    destroy() {}

    untilVisible() {
      return new Promise((resolve) => {
        var timer;
        return timer = setInterval(() => {
          
          if (document.hidden) {
            return;
          }
          
          resolve();
          
          return clearInterval(timer);
        }, 10);
      });
    }

    push(animation, duration, onComplete, interval) {
      var data;
      duration = duration || 800;
      onComplete = onComplete || function() {};
      interval = interval || 50;
      
      if (animation === null) {
        return;
      }
      
      data = this.$this.data('animationData');
      
      if (data === void 0) {
        data = {
          animating: false,
          index: 0,
          looping: true,
          queue: []
        };
      }
      
      data.queue.push({animation, duration, onComplete, interval});
      
      this.$this.data('animationData', data);
      
      if (data.queue.length === 1 && this.index === this.$elements.length - 1) {
        return this.start();
      }
    }

    async start() {
      var $element, element, elements, i, index, len, results;
      
      elements = this.$elements.toArray();
      results = [];
      
      for (index = i = 0, len = elements.length; i < len; index = ++i) {
        element = elements[index];
        // 持續以 `await` 阻擋，直到此頁面在螢幕上可見。
        // 這可以避免瀏覽器因為重新繪製而打亂動畫的順序，如果移除此方法會雜亂無章。
        await this.untilVisible();
        
        $element = $selector(element);
        
        this.$this = $element;
        
        await this.animate(this.getAnimation());
        if (index === elements.length - 1) {
          results.push(this.start());
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    animate({animation, duration, onComplete, interval}) {
      
      return new Promise(async(resolve) => {
        
        this.$this.attr('data-animation', animation).css('animation-duration', `${duration}ms`);
        
        await this.delay();
        
        this.$this.attr('data-animating', true);
        
        this.$this.one('animationend.animation', () => {
          
          return onComplete.call(this.$this.get());
        });
        
        await this.delay(interval);
        
        return resolve();
      });
    }

    getAnimation() {
      var animation, data;
      data = this.$this.data('animationData');
      
      animation = data.queue[data.index];
      
      data.index++;
      
      if (data.index > data.queue.length - 1 && data.looping) {
        data.index = 0;
      }
      
      this.$this.data('animationData', data);
      return animation;
    }

    methods() {
      return {
        // Stop

        stop: () => {
          return ts.fn;
        },
        // Stop All

        'stop all': () => {
          return ts.fn;
        },
        // Clear Queue

        'clear queue': () => {
          return ts.fn;
        },
        // Show

        show: () => {
          return ts.fn;
        },
        // Hide

        hide: () => {
          return ts.fn;
        },
        // Toggle

        toggle: () => {
          return ts.fn;
        },
        // Set Looping

        'set looping': () => {
          return ts.fn;
        },
        // Remove Looping

        'remove looping': () => {
          return ts.fn;
        },
        // Is Visible

        'is visible': () => {},
        // Is Animating

        'is animating': () => {},
        // Is Looping

        'is looping': () => {},
        // Fade In Down

        'fade in down': (duration, onComplete) => {
          this.push('fade in down', duration, onComplete);
          return ts.fn;
        },
        // Fade Out Down

        'fade out down': (duration, onComplete) => {
          this.push('fade out down', duration, onComplete);
          return ts.fn;
        }
      };
    }

  };

  // 模組名稱。
  Transition.module = 'transition';

  // 模組屬性。
  Transition.prototype.props = {
    animation: null,
    reverse: false,
    interval: 0,
    duration: 500,
    onComplete: function() {},
    onAllComplete: function() {},
    onStart: function() {}
  };

  return Transition;

})();

ts(Transition);
