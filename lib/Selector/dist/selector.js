// Generated by CoffeeScript 2.0.0-beta4
// 主要的選擇器函式。
var $selector;

$selector = function(selector, context) {
  var nodes, ref, tag;
  nodes = [];
  // 如果選擇器是文字，但是是標籤（如：`<div>`）就建立新的元素
  if (typeof selector === 'string' && selector[0] === '<') {
    tag = selector.match(/<(.*)\/>|<(.*)>/);
    nodes = [document.createElement((ref = tag[1]) != null ? ref : tag[2])];
  // 如果選擇器是一般的文字，就選取元素。
  } else if (typeof selector === 'string' && context === void 0) {
    document.querySelectorAll(selector).forEach(function(element) {
      return nodes.push(element);
    });
  // 如果選擇器有上下文選擇器，就透過選擇器找出上下文元素。
  } else if (typeof context === 'string') {
    nodes = $selector(selector).find(context).toArray();
  // 如果選擇器是 NodeList 就轉換成元素陣列然後取出來接著繼續。
  } else if (selector instanceof NodeList) {
    selector.forEach(function(element) {
      return nodes.push(element);
    });
  // 如果選擇器是陣列，就當作是元素陣列，取出來然後繼續。
  // 或傳入的是一個選擇器，就取出裡面的元素然後繼續。
  } else if (Array.isArray(selector) || (selector != null ? selector.isSelector : void 0) === true) {
    nodes = nodes.concat(selector);
  // 如果是單個 DOM 元素，就放入選擇器然後繼續。
  } else if (selector instanceof HTMLElement || selector instanceof HTMLDocument || selector instanceof HTMLBodyElement) {
    nodes = [selector];
  }
  // 保存目前的選擇器文字與上下文選擇器文字。
  nodes.selector = typeof selector === 'string' ? selector : null;
  nodes.context = typeof context === 'string' ? context : null;
  // 將自訂的選擇器方法插入到節點陣列中，這樣才能夠串連使用。
  Object.defineProperties(nodes, $selector.fn);
  // 將節點陣列標註為是選擇器，這樣才能判斷傳入的是不是我們自己的選擇器。
  Object.defineProperty(nodes, 'isSelector', {
    value: true
  });
  return nodes;
};

// 函式鏈。
$selector.fn = {};

// 輔助函式。
$selector.helper = {};


$selector.helper.eventAlias = function(event) {
  var alias;
  event = event.split('.');
  alias = event[1] !== void 0 ? `.${event[1]}` : '';
  if (event.indexOf('animationend') !== -1) {
    return `webkitAnimationEnd${alias} mozAnimationEnd${alias} MSAnimationEnd${alias} oanimationend${alias} animationend${alias}`;
  } else if (event.indexOf('transitionend') !== -1) {
    return `webkitTransitionEnd${alias} mozTransitionEnd${alias} oTransitionEnd${alias} msTransitionEnd${alias} transitionend${alias}`;
  } else {
    return event[0];
  }
};

// Get

// 取得選擇器內的指定元素，並且回傳一個 DOM 元素而非選擇器。
$selector.fn.get = {
  value: function(index = 0) {
    return this[index];
  }
};

// ToArray

// 將選擇器轉換成帶有節點的一般陣列。
$selector.fn.toArray = {
  value: function() {
    var array;
    array = [];
    this.forEach(function(element) {
      return array.push(element);
    });
    return array;
  }
};

// Each

// 遍歷整個選擇器陣列。
$selector.fn.each = {
  value: function(callback) {
    this.forEach(function(element, index) {
      return callback.call(element, element, index);
    });
    return this;
  }
};

// CollectSwap

// 將收集到的元素替換掉目前選擇器內的所有元素。
$selector.fn.collectSwap = {
  value: function(callback) {
    var collection, newSelector;
    collection = [];
    this.each(function(element, index) {
      var result;
      result = callback.call(element, element, index);
      if (result === void 0 || result === null) {
        return;
      }
      if (result instanceof NodeList) {
        return result.forEach(function(el) {
          return collection.push(el);
        });
      } else if (Array.isArray(result)) {
        return collection = collection.concat(result);
      } else {
        if (collection.indexOf(result) === -1) {
          return collection.push(result);
        }
      }
    });
    // 透過 Set 型態移除重複的節點。
    collection = new Set(collection);
    // 然後將 Set 轉換成陣列，建立新的選擇器。
    newSelector = $selector([...collection]);
    // 保存選擇器之前的所有節點。
    Object.defineProperty(newSelector, 'prevObject', {
      value: this
    });
    // 回傳這個新的選擇器。
    return newSelector;
  }
};

// Eq

// 取得選擇器的指定元素，然後繼續回傳僅帶有該元素的選擇器。
$selector.fn.eq = {
  value: function(index) {
    return $selector(this.get(index));
  }
};

// Parent

// 回傳元素的父元素選擇器。
$selector.fn.parent = {
  value: function() {
    return this.collectSwap(function() {
      return this.parentNode;
    });
  }
};

// Closest

// 回傳最接近指定的父元素選擇器。
$selector.fn.closest = {
  value: function(selector) {
    return this.collectSwap(function() {
      return this.closest(selector);
    });
  }
};

// Find

// 在目前元素中搜尋指定元素並回傳其選擇器。
$selector.fn.find = {
  value: function(selector) {
    return this.collectSwap(function() {
      return this.querySelectorAll(selector);
    });
  }
};

// Insert Before

$selector.fn.insertBefore = {
  value: function(target) {
    return this.each(function() {
      return $selector(target).each((element) => {
        return element.parentNode.insertBefore(this, element);
      });
    });
  }
};

// Insert After

$selector.fn.insertAfter = {
  value: function(target) {
    return this.each(function() {
      return $selector(target).each((element) => {
        return element.parentNode.insertBefore(this, element.nextSibling);
      });
    });
  }
};

// Wrap

// 將元素用指定元素包覆起來。
$selector.fn.wrap = {
  value: function(element) {
    return this.each(function() {
      if (this.nextSibling) {
        this.parentNode.insertBefore(element, this.nextSibling);
      } else {
        this.parentNode.appendChild(element);
      }
      return element.appendChild(this);
    });
  }
};

// Clone

// 複製元素。
$selector.fn.clone = {
  value: function() {
    return this.collectSwap(function() {
      return this.cloneNode(true);
    });
  }
};

// Append

// 將元素插入在目前選擇器元素的內部最後面。
$selector.fn.append = {
  value: function(element) {
    var shouldClone;
    shouldClone = this.length !== 1;
    if (element.isSelector !== void 0) {
      return this.each(function() {
        return element.each((e) => {
          return this.appendChild(shouldClone ? e.cloneNode(true) : e);
        });
      });
    } else if (typeof element === 'string') {
      return this.each(function() {
        return this.insertAdjacentHTML('beforeend', element);
      });
    } else {
      return this.each(function() {
        return this.appendChild(shouldClone ? element.cloneNode(true) : element);
      });
    }
  }
};

// AppendTo

// 將目前選擇器元素插入到指定元素的內部最後面。
$selector.fn.appendTo = {
  value: function(selector) {
    return this.each(function() {
      return $selector(selector).append(this);
    });
  }
};

// Prepend

// 將元素插入在目前選擇器元素的內部最前面。
$selector.fn.prepend = {
  value: function(element) {
    var shouldClone;
    shouldClone = this.length !== 1;
    if (element.isSelector !== void 0) {
      return this.each(function() {
        return element.each((e) => {
          return this.prepend(shouldClone ? e.cloneNode(true) : e);
        });
      });
    } else if (typeof element === 'string') {
      return this.each(function() {
        return this.insertAdjacentHTML('afterbegin', element);
      });
    } else {
      return this.each(function() {
        return this.prepend(shouldClone ? element.cloneNode(true) : element);
      });
    }
  }
};

// PrependTo

// 將目前選擇器元素插入到指定元素的內部最前面。
$selector.fn.prependTo = {
  value: function(selector) {
    return this.each(function() {
      return $selector(selector).prepend(this);
    });
  }
};

// Remove

// 將選擇器元素從頁面上中移除。
$selector.fn.remove = {
  value: function() {
    return this.each(function() {
      var ref;
      return (ref = this.parentNode) != null ? ref.removeChild(this) : void 0;
    });
  }
};

// Is

// 選擇一些元素，然後用來比對目前的選擇器元素是否在這群當中。
$selector.fn.is = {
  value: function(selector) {
    var compareElements, isInElements;
    compareElements = document.querySelectorAll(selector);
    isInElements = false;
    this.each(function() {
      return compareElements.forEach(function(compareElement) {
        if (this === compareElement) {
          return isInElements = true;
        }
      }, this);
    });
    return isInElements;
  }
};

// Slice

// 替元素陣列進行切分。
$selector.fn.slice = {
  value: function(from, to) {
    return $selector(this.toArray().slice(from, to));
  }
};

// Children

// 取得容器裡的第一層子節點。
$selector.fn.children = {
  value: function(selector) {
    return this.collectSwap(function() {
      return this.querySelectorAll(selector != null ? `:scope > ${selector}` : ':scope > *');
    });
  }
};


$selector.fn.replaceWith = {
  value: function(selector) {
    var element;
    element = $selector(selector).get();
    return this.each(function() {
      return this.replaceWith(element);
    });
  }
};


$selector.fn.last = {
  value: function() {
    return this.eq(this.length - 1);
  }
};

// Next

// 下一個元素。
$selector.fn.next = {
  value: function() {
    return this.collectSwap(function() {
      return this.nextElementSibling;
    });
  }
};

// Prev

// 上一個元素。
$selector.fn.prev = {
  value: function() {
    return this.collectSwap(function() {
      return this.previousElementSibling;
    });
  }
};

// NextAll

// 這個元素之後的所有同階層元素。
$selector.fn.nextAll = {
  value: function(selector) {
    return this.collectSwap(function() {
      var $children, $parent, $self, index;
      $self = $selector(this);
      $parent = $self.parent();
      $children = selector != null ? $parent.find(`:scope > ${selector}`) : $parent.find(':scope > *');
      index = $self.index();
      return $children.slice(index + 1);
    });
  }
};

// PrevAll

// 這個元素之前的所有同階層元素。
$selector.fn.prevAll = {
  value: function(selector) {
    return this.collectSwap(function() {
      var $children, $parent, $self, index;
      $self = $selector(this);
      $parent = $self.parent();
      $children = selector != null ? $parent.find(`:scope > ${selector}`) : $parent.find(':scope > *');
      index = $self.index();
      return $children.slice(0, index);
    });
  }
};

// AddBack

// 在目前的選擇器節點陣列中加上先前選擇的所有節點。
$selector.fn.addBack = {
  value: function() {
    if (this.prevObject) {
      this.prevObject.toArray().forEach((element) => {
        return this.push(element);
      });
    }
    return this;
  }
};

// Index

// 該元素在容器內的索引。
$selector.fn.index = {
  value: function() {
    var index, node;
    node = this.get(0);
    index = 0;
    if (node == null) {
      return -1;
    }
    while ((node = node.previousElementSibling)) {
      index++;
    }
    return index;
  }
};

// Attr

// 取得或是建立新的標籤到目前的選擇器元素。
$selector.fn.attr = {
  value: function(name, value) {
    var ref;
    // 如果有 value 就設置簡單鍵值資料。
    if (value !== void 0) {
      return this.each(function() {
        return this.setAttribute(name, value);
      });
    // 如果傳入的是物件就設置多重資料。
    } else if (typeof name === 'object') {
      return this.each(function() {
        var key, results;
        results = [];
        for (key in name) {
          results.push(this.setAttribute(key, name[key]));
        }
        return results;
      });
    } else {
      return (ref = this.get()) != null ? ref.getAttribute(name) : void 0;
    }
  }
};

// RemoveAttr

// 移除目前選擇器元素的指定標籤。
$selector.fn.removeAttr = {
  value: function(name) {
    return this.each(function() {
      return this.removeAttribute(name);
    });
  }
};

// AddClass

// 在目前選擇器元素插入新的樣式類別名稱。
$selector.fn.addClass = {
  value: function(names) {
    return this.each(function() {
      return DOMTokenList.prototype.add.apply(this.classList, names.split(' ').filter(Boolean));
    });
  }
};

// RemoveClass

// 移除目前選擇器元素的指定樣式類別。
$selector.fn.removeClass = {
  value: function(names) {
    return this.each(function() {
      return DOMTokenList.prototype.remove.apply(this.classList, names.split(' ').filter(Boolean));
    });
  }
};

// ToggleClass

// 切換目前選擇器元素的樣式。
$selector.fn.toggleClass = {
  value: function(names) {
    return this.each(function() {
      return names.split(' ').forEach(function(name) {
        return this.classList.toggle(name);
      }, this);
    });
  }
};

// HasClass

// 回傳選擇器元素是否帶有指定樣式類別，是布林值。
$selector.fn.hasClass = {
  value: function(name) {
    var ref;
    return (ref = this.get(0)) != null ? ref.classList.contains(name) : void 0;
  }
};

// CSS

// 將選擇器元素套用指定的 CSS 樣式。
$selector.fn.css = {
  value: function(name, value) {
    var key;
    // 有 name 也有 value 就設置樣式。
    if (typeof name === 'string' && value !== void 0) {
      return this.each(function() {
        return this.style[name] = value;
      });
    // 有 name 但沒有 value 就取得樣式。
    } else if (typeof name === 'string' && value === void 0) {
      if (this.get() != null) {
        return document.defaultView.getComputedStyle(this.get(), null).getPropertyValue(name);
      } else {
        return null;
      }
    // 有 name 但他是 object，就設置多重樣式。
    } else if (typeof name === 'object') {
      for (key in name) {
        this.each(function() {
          return this.style[key] = name[key];
        });
      }
      return this;
    }
  }
};

// On

// 綁定並註冊一個事件監聽器。
$selector.fn.on = {
  value: function(events, handler, options) {
    events = $selector.helper.eventAlias(events);
    // $events.click =
    // {
    //     anonymous: [
    //         {
    //             once: true,
    //             func: func()
    //         }
    //     ]
    //     alias1:
    //     {
    //         once: true,
    //         func: func()
    //     }
    // }
    return this.each(function() {
      if (this.addEventListener === void 0) {
        return;
      }
      if (this.$events === void 0) {
        this.$events = {};
      }
      return events.split(' ').forEach(function(eventName) {
        var event, eventAlias, hasAlias;
        event = eventName.split('.');
        // 透過事件的「event.alias」取得「點」後面的別名。
        hasAlias = event.length > 1;
        eventName = event[0];
        eventAlias = hasAlias ? event[1] : null;
        // 如果事件還沒在這個物件內產生過，就初始化一個事件結構。
        if (this.$events[eventName] === void 0) {
          this.$events[eventName] = {
            anonymous: []
          };
          // 然後建立一個管理多個事件的事件管理處理程式。
          this.addEventListener(eventName, function(event) {
            var alias, index, item, results;
            // 如果該事件已經被移除則停止後續的反應。
            if (this.$events[eventName] === void 0) {
              return;
            }
            results = [];
            // 將被觸發的事件裡面的所有處理程式全部呼叫一次。
            for (alias in this.$events[eventName]) {
              // 如果這是匿名函式陣列的話。
              if (alias === 'anonymous') {
                // 將所有匿名函式呼叫一次。
                //@$events[eventName][alias].forEach (item, index) ->
                //    item.func.call(@, event)
                //    # 如果這個程式只能被呼叫一次就在處理程式呼叫後移除。
                //    if item.once is true
                //        @$events[eventName][alias].splice(index, 1)
                //, @
                index = this.$events[eventName][alias].length;
                results.push((function() {
                  var results1;
                  results1 = [];
                  while (index--) {
                    item = this.$events[eventName][alias][index];
                    item.func.call(this, event);
                    // 如果這個程式只能被呼叫一次就在處理程式呼叫後移除。
                    if (item.once === true) {
                      results1.push(this.$events[eventName][alias].splice(index, 1));
                    } else {
                      results1.push(void 0);
                    }
                  }
                  return results1;
                }).call(this));
              } else {
                // 不然如果是別名函式的話。
                this.$events[eventName][alias].func.call(this, event);
                // 如果這個程式只能被呼叫一次就在處理程式呼叫後移除。
                if (this.$events[eventName][alias].once === true) {
                  results.push(delete this.$events[eventName][alias]);
                } else {
                  results.push(void 0);
                }
              }
            }
            return results;
          });
        }
        // 將新的事件處理程式註冊到事件清單中。
        // 如果有別名，就不要推送到匿名陣列中，我們替這個別名另開物件。
        if (hasAlias) {
          return this.$events[eventName][eventAlias] = {
            func: handler,
            once: options != null ? options.once : void 0
          };
        } else {
          // 如果沒有，就照常推進匿名陣列中。
          return this.$events[eventName].anonymous.push({
            func: handler,
            once: options != null ? options.once : void 0
          });
        }
      }, this);
    });
  }
};

// One

// 綁定一次性的事件監聽器，當被觸發之後就會被移除。
$selector.fn.one = {
  value: function(events, handler) {
    events = $selector.helper.eventAlias(events);
    return this.each(function() {
      return $selector(this).on(events, handler, {
        once: true
      });
    });
  }
};

// Off

// 註銷事件監聽器。
$selector.fn.off = {
  value: function(events, handler) {
    events = $selector.helper.eventAlias(events);
    return this.each(function() {
      return events.split(' ').forEach((eventName) => {
        var event, eventAlias, hasAlias;
        if (this.$events === void 0) {
          return;
        }
        if (this.$events[eventName] === void 0) {
          return;
        }
        event = eventName.split('.');
        // 透過事件的「event.alias」取得「點」後面的別名。
        hasAlias = event.length > 1;
        eventName = event[0];
        eventAlias = hasAlias ? event[1] : null;
        if (hasAlias) {
          delete this.$events[eventName][eventAlias];
          return;
        }
        if (handler === void 0) {
          this.$events[eventName].anonymous = [];
          return;
        }
        return this.$events[eventName].anonymous.forEach((item, index) => {
          if (handler === item.func) {
            return this.$events[eventName].anonymous.splice(index, 1);
          }
        });
      }, this);
    });
  }
};

// Trigger

// 觸發指定事件。
$selector.fn.trigger = {
  value: function(events) {
    if (events === 'animationend') {
      events = 'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend';
    }
    if (events === 'transitionend') {
      events = 'webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend';
    }
    return this.each(function() {
      return events.split(' ').forEach((eventName) => {
        var event;
        event = new Event(eventName);
        return this.dispatchEvent(event);
      });
    });
  }
};

// Emulate

// 在指定的秒數過後觸發指定事件，若已被觸發則不再次觸發。
// 這能用以強迫讓某個事件發生。
$selector.fn.emulate = {
  value: function(event, duration) {
    return this.each(function() {
      var called;
      called = false;
      $selector(this).one(event, function() {
        return called = true;
      });
      return setTimeout(() => {
        if (!called) {
          return $selector(this).trigger(event);
        }
      }, duration);
    });
  }
};

// Text

// 變更或取得選擇器元素的內容文字。
$selector.fn.text = {
  value: function(text) {
    var ref;
    if (text !== void 0) {
      return this.each(function() {
        return this.innerText = text;
      });
    } else {
      return (ref = this.get()) != null ? ref.innerText : void 0;
    }
  }
};

// Val

// 變更或取得選擇器元素的值。
$selector.fn.val = {
  value: function(value) {
    var ref;
    if (value !== void 0) {
      return this.each(function() {
        return this.value = value;
      });
    } else {
      return (ref = this.get()) != null ? ref.value : void 0;
    }
  }
};

// HTML

// 變更或取得選擇器元素的 HTML。
$selector.fn.html = {
  value: function(html) {
    var ref;
    if (html !== void 0) {
      return this.each(function() {
        return this.innerHTML = html;
      });
    } else {
      return (ref = this.get()) != null ? ref.innerHTML : void 0;
    }
  }
};

// Empty

// 將選擇器元素的內容清除，例如值或文字。
$selector.fn.empty = {
  value: function() {
    return this.each(function() {
      if (this.value !== void 0) {
        this.value = null;
      }
      if (this.innerHTML !== void 0) {
        this.innerHTML = null;
      }
      if (this.innerText !== void 0) {
        return this.innerText = null;
      }
    });
  }
};

// Prop

// 變更或取得選擇器元素的屬性，例如 `.src`、`.width`。
$selector.fn.prop = {
  value: function(name, value) {
    var key, ref;
    // 有 name 也有 value 就設置屬性。
    if (typeof name === 'string' && value !== void 0) {
      return this.each(function() {
        return this[name] = value;
      });
    // 有 name 但沒有 value 就取得屬性。
    } else if (typeof name === 'string' && value === void 0) {
      return (ref = this.get()) != null ? ref[name] : void 0;
    // 有 name 但他是 object，就設置多重屬性。
    } else if (typeof name === 'object') {
      for (key in name) {
        this.each(function() {
          return this[key] = name[key];
        });
      }
      return this;
    }
  }
};

// Data

// 在選擇器元素中存放資料，類似 Attr 但頁面不可見。
$selector.fn.data = {
  value: function(name, value) {
    var key, ref, ref1;
    // 有 name 也有 value 就設置資料。
    if (typeof name === 'string' && value !== void 0) {
      return this.each(function() {
        if (this.$data === void 0) {
          this.$data = {};
        }
        return this.$data[name] = value;
      });
    // 有 name 但沒有 value 就取得資料。
    } else if (typeof name === 'string' && value === void 0) {
      return (ref = this.get()) != null ? (ref1 = ref.$data) != null ? ref1[name] : void 0 : void 0;
    // 有 name 但他是 object，就設置多重樣式。
    } else if (typeof name === 'object') {
      for (key in name) {
        this.each(function() {
          if (this.$data === void 0) {
            this.$data = {};
          }
          return this.$data[key] = name[key];
        });
      }
      return this;
    }
  }
};

// Remove Data

// 移除指定的資料。
$selector.fn.removeData = {
  value: function(name) {
    return this.each(function() {
      if (this.$data[name] != null) {
        return delete this.$data[name];
      }
    });
  }
};

// Has Timer

// 確認是否有指定的計時器。
$selector.fn.hasTimer = {
  value: function(name) {
    var ref, ref1;
    return ((ref = this.get(0)) != null ? (ref1 = ref.$timers) != null ? ref1[name] : void 0 : void 0) != null;
  }
};

// Get Timer

// 取得計時器內容。
$selector.fn.getTimer = {
  value: function(name) {
    var ref, ref1;
    return (ref = this.get(0)) != null ? (ref1 = ref.$timers) != null ? ref1[name] : void 0 : void 0;
  }
};

// Set Timer

// 設置一個新的計時器。
$selector.fn.setTimer = {
  value: function(options) {
    options = Object.assign({}, {
      name: '',
      callback: function() {},
      interval: 0,
      looping: false,
      visible: false
    }, options);
    return this.each(function() {
      var timer;
      if (this.$timers === void 0) {
        this.$timers = {};
      }
      if (this.$timers[options.name] !== void 0) {
        clearInterval(this.$timers[options.name].timer);
      }
      timer = () => {
        var ref;
        // 當設置有說明，頁面不可見的時候就不要繼續計時。
        if (options.visible && document.hidden) {
          return;
        }
        // 替計時器加上 10 毫秒。
        this.$timers[options.name].passed += 10;
        // 如果計時器的經過時間還不到使用者設定的時間
        // 就返回而不要繼續執行。
        if (this.$timers[options.name].passed < options.interval) {
          return;
        }
        // 呼叫回呼函式。
        options.callback();
        // 如果要循環的話，就在計時器執行後重設時間即可。
        if (options.looping) {
          return this.$timers[options.name].passed = 0;
        } else {
          // 不然就移除計時器資訊。
          return clearInterval((ref = this.$timers[options.name]) != null ? ref.timer : void 0);
        }
      };
      // 移除在 DOM 元素內的這個計時器物件。
      //delete @$timers[options.name]

      // 在此元素內初始化計時器物件。
      return this.$timers[options.name] = {
        timer: setInterval(timer, 10),
        passed: 0,
        callback: options.callback,
        interval: options.interval,
        looping: options.looping,
        visible: options.visible,
        initializer: timer,
        paused: false
      };
    });
  }
};

// Pause Timer

// 暫停一個計時器。
$selector.fn.pauseTimer = {
  value: function(name) {
    return this.each(function() {
      var ref;
      if (((ref = this.$timers) != null ? ref[name] : void 0) == null) {
        return;
      }
      // 清除計數計時器達到暫停效果。
      clearInterval(this.$timers[name].timer);
      // 表示暫停。
      return this.$timers[name].paused = true;
    });
  }
};

// Play Timer

// 重啟一個計時器。
$selector.fn.playTimer = {
  value: function(name) {
    return this.each(function() {
      var ref;
      if (((ref = this.$timers) != null ? ref[name] : void 0) == null) {
        return;
      }
      if (!this.$timers[name].paused) {
        return;
      }
      // 重新初始化計數計時器來達到繼續的效果。
      this.$timers[name].timer = setInterval(this.$timers[name].initializer, 10);
      // 表示重新啟動。
      return this.$timers[name].paused = false;
    });
  }
};

// Remove Timer

// 移除一個計時器。
$selector.fn.removeTimer = {
  value: function(name) {
    return this.each(function() {
      var ref;
      if (((ref = this.$timers) != null ? ref[name] : void 0) == null) {
        return;
      }
      // 清除計數計時器。
      clearInterval(this.$timers[name].timer);
      // 移除在 DOM 元素內的計時器物件。
      return delete this.$timers[name];
    });
  }
};
