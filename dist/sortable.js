// Generated by CoffeeScript 2.0.0-beta4
(function() {
  // ------------------------------------------------------------------------
  // 變數與常數設置
  // ------------------------------------------------------------------------

  // 模組名稱。
  var Attribute, ClassName, EVENT_NAMESPACE, Error, Event, MODULE_NAMESPACE, Metadata, NAME, Selector, Settings;

  NAME = 'sortable';

  // 模組事件鍵名。
  EVENT_NAMESPACE = `.${NAME}`;

  // 模組命名空間。
  MODULE_NAMESPACE = `module-${NAME}`;

  // 滑鼠拖曳出外，回來可以點擊依然可以放到 pull 容器

  // 模組設定。
  Settings = {
    // 消音所有提示，甚至是錯誤訊息。
    silent: false,
    // 顯示除錯訊息。
    debug: true,
    // 監聽 DOM 結構異動並自動重整快取。
    observeChanges: true,
    // 指定的拖曳把手選擇器，設置為 `false` 則為整個元素皆可拖曳。
    handle: false,
    // 到拖曳開始之前必須按住的指定毫秒數，避免點擊成為不必要的拖曳。
    delay: 350,
    // 是否能在相同拖放排序內重新排序。
    sort: true,
    // 群組名稱，相同的名稱拖放排序清單可以交替其項目。
    group: false,
    // 此拖放排序的支援模式。（`all` 表示可拖放、`put` 表示僅可放入、`pull` 表示僅可移出、`all` 表示都可）
    mode: 'all',
    // 這個拖放排序是否已垂直清單為主，改為 `false` 會有利於水平清單。
    vertical: true,
    // 當拖拉開始時所會呼叫的回呼函式。
    onDragStart: () => {},
    // 當拖拉途中所會呼叫的回呼函式，間隔是 350 毫秒。
    onDrag: () => {},
    // 當拖拉結束並丟下元素時所會呼叫的回呼函式。
    onDrop: () => {},
    // 當放下被禁止（如：範圍外、被回呼函式拒絕）時所會呼叫的函式。
    onDeny: () => {},
    // 當放下時跟一開始沒有差異時所會呼叫的回呼函式。
    onCancel: () => {},
    // 當項目在相同清單進行重新排序時所會呼叫的回呼函式。
    // onSort        : =>
    // 當有變動（新增、移除、重新排序）時所會呼叫的回呼函式。
    onChange: (valueElement, value) => {},
    // 當項目新增時所會呼叫的回呼函式，回傳 `false` 表示不接受此新增。
    onAdd: (valueElement, value) => {
      return console.log(this, valueElement, value);
    },
    // 當項目被移出時所會呼叫的回呼函式。
    onRemove: (valueElement, value) => {}
  };

  // 事件名稱。
  Event = {
    DRAGSTART: `dragstart${EVENT_NAMESPACE}`,
    DRAG: `drag${EVENT_NAMESPACE}`,
    DROP: `drop${EVENT_NAMESPACE}`,
    DENY: `deny${EVENT_NAMESPACE}`,
    CANCEL: `cancel${EVENT_NAMESPACE}`,
    CHANGE: `change${EVENT_NAMESPACE}`,
    ADD: `add${EVENT_NAMESPACE}`,
    REMOVE: `remove${EVENT_NAMESPACE}`,
    MOUSEMOVE: `mousemove${EVENT_NAMESPACE}`,
    MOUSEUP: `mouseup${EVENT_NAMESPACE}`,
    MOUSEDOWN: `mousedown${EVENT_NAMESPACE}`
  };

  // 中繼資料名稱。
  Metadata = {
    X_OFFSET: 'xOffset',
    Y_OFFSET: 'yOffset'
  };

  // 元素標籤。
  Attribute = {
    GROUP: 'data-draggable-group',
    CONTAINER: 'data-draggable-container',
    DRAGGABLE: 'data-draggable',
    DRAGGING: 'data-draggable-dragging',
    VALUE: 'data-value',
    GHOST: 'data-draggable-ghost',
    PLACEHOLDER: 'data-draggable-placeholder',
    NATIVE_DRAGGABLE: 'draggable',
    HIDDEN: 'hidden'
  };

  // 樣式名稱。
  ClassName = {};

  // 選擇器名稱。
  Selector = {
    BODY: 'body',
    NATIVE_DRAGGABLE: `[${Attribute.NATIVE_DRAGGABLE}]`,
    DRAGGING: `[${Attribute.DRAGGING}]`,
    DRAGGABLE: `[${Attribute.DRAGGABLE}]`,
    GHOST: `[${Attribute.GHOST}]`,
    PLACEHOLDER: `[${Attribute.PLACEHOLDER}]`,
    CONTAINER: `[${Attribute.CONTAINER}]`,
    PLACEHOLDER: `[${Attribute.PLACEHOLDER}]`,
    GROUP: `[${Attribute.GROUP}]`,
    HIDDEN_DRAGGABLE: `[${Attribute.DRAGGABLE}][${Attribute.HIDDEN}]`,
    TRUE_DRAGGABLE: `[${Attribute.DRAGGABLE}]:not([${Attribute.HIDDEN}])`,
    DRAGGABLE_VALUE: (value) => {
      return `[${Attribute.VALUE}='${value}']`;
    }
  };

  // 錯誤訊息。
  Error = {};

  // ------------------------------------------------------------------------
  // 模組註冊
  // ------------------------------------------------------------------------
  ts.register({NAME, MODULE_NAMESPACE, Error, Settings}, ({$allModules, $this, element, debug, settings}) => {
    var module;
    // ------------------------------------------------------------------------
    // 區域變數
    // ------------------------------------------------------------------------

    // ------------------------------------------------------------------------
    // 模組定義
    // ------------------------------------------------------------------------
    return module = {
      sort: (values) => {
        var i, len, results, value;
        results = [];
        for (i = 0, len = values.length; i < len; i++) {
          value = values[i];
          results.push($this.find(Selector.DRAGGABLE_VALUE(value)).appendTo(element));
        }
        return results;
      },
      enable: () => {},
      disable: () => {},
      hide: {
        original: (original) => {
          return $(original).attr(Attribute.HIDDEN, 'hidden');
        }
      },
      unhide: {
        original: () => {
          return $(Selector.HIDDEN_DRAGGABLE).removeAttr(Attribute.HIDDEN);
        }
      },
      set: {
        dragging: (element) => {
          return ts(element).attr(Attribute.DRAGGING, 'true');
        }
      },
      get: {
        $dragging: () => {
          return ts(Selector.DRAGGING);
        },
        $placeholder: () => {
          return ts(Selector.PLACEHOLDER);
        },
        $original: () => {
          return ts(Selector.HIDDEN_DRAGGABLE);
        },
        dragging: {
          element: () => {
            return ts(Selector.HIDDEN_DRAGGABLE).get();
          },
          value: () => {
            return ts(Selector.HIDDEN_DRAGGABLE).attr(Attribute.VALUE);
          }
        },
        group: {
          name: () => {
            return $this.attr(Attribute.GROUP);
          }
        },
        mode: () => {
          return settings.mode;
        },
        sort: () => {
          return settings.sort;
        },
        value: () => {
          var values;
          values = [];
          $this.find(Selector.DRAGGABLE).each(function() {
            var value;
            value = ts(this).attr(Attribute.VALUE);
            if (value) {
              return values.push(value);
            }
          });
          return values;
        }
      },
      reset: {
        dragging: () => {
          return ts(Selector.DRAGGING).removeAttr(Attribute.DRAGGING);
        }
      },
      is: {
        draggable: (element) => {
          return ts(element).attr(Attribute.DRAGGABLE) === 'true';
        },
        child: (element) => {
          return $this.contains(element);
        }
      },
      same: {
        group: (x, y) => {
          var $container, groupName;
          $container = ts.fromPoint(x, y).closest(Selector.CONTAINER);
          if ($container.is(element)) {
            return true;
          }
          groupName = $container.sortable('get group name');
          if (groupName === null) {
            return false;
          }
          return groupName === module.get.group.name();
        }
      },
      has: {
        dragging: () => {
          return $this.find(Selector.DRAGGING).length !== 0;
        },
        placeholder: () => {
          return $this.find(Selector.PLACEHOLDER).length !== 0;
        }
      },
      create: {
        ghost: (original, x, y) => {
          var $original, rect;
          $original = ts(original);
          rect = $original.rect();
          return $original.clone().attr(Attribute.GHOST, 'true').data({
            [`${Metadata.X_OFFSET}`]: x - rect.x,
            [`${Metadata.Y_OFFSET}`]: y - rect.y
          }).css({
            width: rect.width,
            height: rect.height
          }).appendTo(Selector.BODY);
        },
        placeholder: (original) => {
          return ts(original).clone().attr(Attribute.PLACEHOLDER, 'true').appendTo(Selector.BODY);
        }
      },
      remove: {
        ghost: () => {
          return ts(Selector.GHOST).remove();
        },
        placeholder: () => {
          return ts(Selector.PLACEHOLDER).remove();
        }
      },
      move: {
        ghost: (x, y) => {
          var $ghost;
          $ghost = ts(Selector.GHOST);
          return $ghost.css({
            top: y - $ghost.data(Metadata.Y_OFFSET),
            left: x - $ghost.data(Metadata.X_OFFSET)
          });
        },
        placeholder: (x, y) => {
          var $container, $draggable, $last, $pointing, isDraggingFirstChild, isFirstChild, isLefter, isUpper, rect;
          $pointing = ts.fromPoint(x, y);
          $draggable = $pointing.closest(Selector.DRAGGABLE);
          if ($draggable.length === 0) {
            $container = $pointing.closest(Selector.CONTAINER);
            if ($container.length !== 0) {
              if ($container.find(Selector.TRUE_DRAGGABLE).length === 0) {
                module.insert.placeholder($container);
                return;
              } else {
                rect = $container.rect();
                isUpper = y - rect.y < rect.height / 2;
                if (!isUpper) {
                  $last = $container.find(Selector.TRUE_DRAGGABLE).last();
                  if ($last.length !== 0) {
                    module.append.placeholder('after', $last);
                    return;
                  }
                }
              }
            }
            return;
          }
          rect = $draggable.rect();
          isUpper = y - rect.y < rect.height / 2;
          isLefter = x - rect.x < rect.width / 2;
          isFirstChild = $draggable.prev().length === 0;
          isDraggingFirstChild = ts(Selector.DRAGGING).prev().length === 0;
          if (isUpper) {
            if (isFirstChild || isDraggingFirstChild) {
              return ts(Selector.PLACEHOLDER).insertBefore($element);
            } else {
              return ts(Selector.PLACEHOLDER).insertBefore($element);
            }
          } else {
            return ts(Selector.PLACEHOLDER).insertAfter($element);
          }
        },
        original: (x, y) => {
          var $dragging, $placeholder;
          $dragging = module.get.$dragging();
          $placeholder = module.get.$placeholder();
          return $dragging.insertAfter($placeholder);
        }
      },
      append: {
        placeholder: (order, to) => {
          var $placeholder;
          $placeholder = module.get.$placeholder();
          switch (order) {
            case 'before':
              return $placeholder.insertBefore(to);
            case 'after':
              return $placeholder.insertAfter(to);
          }
        }
      },
      insert: {
        placeholder: (to) => {
          var $placeholder;
          $placeholder = module.get.$placeholder();
          return $placeholder.appendTo(to);
        }
      },
      trigger: {
        dragStart: () => {
          return $this.trigger(Event.DRAGSTART, module.get.dragging.element(), module.get.dragging.value());
        },
        drag: () => {
          return $this.trigger(Event.DRAG, module.get.dragging.element(), module.get.dragging.value());
        },
        drop: () => {
          return $this.trigger(Event.DROP, module.get.dragging.element(), module.get.dragging.value());
        },
        deny: () => {
          return $this.trigger(Event.DENY, module.get.dragging.element(), module.get.dragging.value());
        },
        cancel: () => {
          return $this.trigger(Event.CANCEL, module.get.dragging.element(), module.get.dragging.value());
        },
        change: (valueElement, value) => {
          return $this.trigger(Event.CHANGE, element, valueElement, value);
        },
        add: (valueElement, value) => {
          debug('發生 ADD 事件', element, valueElement, value);
          return settings.onAdd.call(element, valueElement, value);
        },
        //$this.trigger Event.ADD, element, valueElement, value
        remove: (valueElement, value) => {
          return $this.trigger(Event.REMOVE, element, valueElement, value);
        }
      },
      bind: {
        mousemove: () => {
          return ts(Selector.BODY).on(Event.MOUSEMOVE, (event) => {
            var $container, $element, $lastDraggable, $placeholderContainer, hasPlaceholder, isSameNode;
            //debug '發生 MOUSEMOVE 事件', element, @
            module.move.ghost(event.clientX, event.clientY);
            if (!module.has.dragging()) {
              return;
            }
            if (!module.same.group(event.clientX, event.clientY)) {
              return;
            }
            $element = ts.fromPoint(event.clientX, event.clientY);
            $container = $element.closest(Selector.CONTAINER);
            isSameNode = $container.is(element);
            hasPlaceholder = module.has.placeholder();
            if ($container.sortable('get mode') === 'pull') {
              return;
            }
            if (!settings.sort && isSameNode && hasPlaceholder) {
              return;
            }
            $placeholderContainer = ts(Selector.PLACEHOLDER).closest(Selector.CONTAINER);
            if (!isSameNode && $placeholderContainer.sortable('get mode') === 'put' && $placeholderContainer.sortable('get sort') === 'true') {
              return;
            }
            if (!isSameNode && $container.sortable('get sort') === 'false') {
              if ($container.find(Selector.DRAGGABLE).length === 0) {
                module.insert.placeholder($container);
              } else {
                $lastDraggable = $container.find(Selector.DRAGGABLE).last();
                module.append.placeholder('after', $lastDraggable);
              }
              return;
            }
            if (!settings.sort && isSameNode && !hasPlaceholder) {
              module.append.placeholder('after', module.get.$original());
              return;
            }
            return module.move.placeholder(event.clientX, event.clientY);
          });
        },
        events: () => {
          var id;
          $this.on(Event.DRAGSTART, (event, context) => {
            debug('發生 DRAGSTART 事件', context);
            return settings.onDragStart.call(context, event);
          });
          $this.on(Event.DRAG, (event, context) => {
            //debug '發生 DRAG 事件', context
            return settings.onDrag.call(context, event);
          });
          $this.on(Event.DROP, (event, context) => {
            debug('發生 DROP 事件', context);
            return settings.onDrop.call(context, event);
          });
          $this.on(Event.DENY, (event, context) => {
            debug('發生 DENY 事件', context);
            return settings.onDeny.call(context, event);
          });
          $this.on(Event.CANCEL, (event, context) => {
            debug('發生 CANCEL 事件', context);
            return settings.onCancel.call(context, event);
          });
          $this.on(Event.CHANGE, (event, context, valueElement, value) => {
            debug('發生 CHANGE 事件', context, valueElement, value);
            return settings.onChange.call(context, event, valueElement, value);
          });
          $this.on(Event.REMOVE, (event, context, valueElement, value) => {
            debug('發生 REMOVE 事件', context, valueElement, value);
            return settings.onRemove.call(context, event, valueElement, value);
          });
          id = null;
          ts(Selector.BODY).on(Event.MOUSEDOWN, (event) => {
            var draggable, target;
            //debug '發生 MOUSEDOWN 事件', element, @
            target = event.target;
            if (settings.handle !== false) {
              if (!ts(target).is(settings.handle)) {
                return;
              }
            }
            draggable = ts(target).closest(Selector.DRAGGABLE);
            if (!module.is.draggable(target)) {
              if (draggable.length === 0) {
                return;
              } else {
                target = draggable;
              }
            }
            if (!module.is.child(target)) {
              return;
            }
            if (settings.mode === 'put' && !settings.sort) {
              return;
            }
            module.trigger.dragStart();
            id = setInterval(() => {
              return module.trigger.drag();
            }, 350);
            module.create.ghost(target, event.clientX, event.clientY);
            module.create.placeholder(target);
            module.move.ghost(event.clientX, event.clientY);
            module.move.placeholder(event.clientX, event.clientY);
            module.set.dragging(target);
            module.hide.original(target);
            return module.bind.mousemove();
          });
          return ts(Selector.BODY).on(Event.MOUSEUP, (event) => {
            var $container, allowed, isSameNode, newValue, oldValue;
            debug('發生 MOUSEUP 事件', element, this);
            clearInterval(id);
            module.remove.ghost();
            ts(Selector.BODY).off(Event.MOUSEMOVE);
            if (!module.has.dragging()) {
              return;
            }
            module.trigger.drop();
            $container = ts(event.target).closest(Selector.CONTAINER);
            if ($container.length !== 0) {
              isSameNode = $container.is(element);
            } else {
              isSameNode = false;
            }
            if (isSameNode) {
              oldValue = module.get.value();
              module.move.original();
              newValue = module.get.value();
              if (oldValue.toString() !== '' || newValue.toString() !== '') {
                if (oldValue.toString() === newValue.toString()) {
                  module.trigger.cancel();
                } else {
                  module.trigger.change();
                }
              }
            } else {
              allowed = $container.sortable('trigger add');
              if (allowed) {
                module.move.original();
                $container.sortable('trigger change');
                module.trigger.remove();
                module.trigger.change();
              } else {
                module.trigger.cancel();
                module.trigger.deny();
              }
            }
            module.remove.placeholder();
            module.unhide.original();
            return module.reset.dragging();
          });
        }
      },
      // ------------------------------------------------------------------------
      // 基礎方法
      // ------------------------------------------------------------------------
      initialize: () => {
        debug('初始化拖放排序', element);
        module.bind.events();
        $this.find(Selector.NATIVE_DRAGGABLE).removeAttr(Attribute.NATIVE_DRAGGABLE).attr(Attribute.DRAGGABLE, 'true');
        $this.attr(Attribute.CONTAINER, true);
        if (settings.group !== false) {
          return $this.attr(Attribute.GROUP, settings.group);
        }
      },
      instantiate: () => {
        return debug('實例化拖放排序', element);
      },
      refresh: () => {
        return $allModules;
      },
      destroy: () => {
        debug('摧毀拖放排序', element);
        $this.removeData(MODULE_NAMESPACE).off(EVENT_NAMESPACE);
        return $allModules;
      }
    };
  });

}).call(this);
